pub enum Error {
    UnexpectedIndentation {
        line_number: usize,
        present_indentation: usize,
        expected_indentation_levels: Vec<usize>,
    },
}

mod filler {
    use crate::{Filler, Word};

    pub enum Error {}

    pub fn parse(words: &str) -> Result<Filler, Error> {
        Ok(Filler {
            words: words
                .split_whitespace()
                .map(|word| Word::Raw(word))
                .collect(),
        })
    }
}

mod lines {
    use crate::ActionInvocation;

    pub enum Error {
        UnexpectedIndentation {
            line_index: usize,
            present_indentation_level: usize,
            expected_indentation_levels: Vec<usize>,
        },
    }

    pub fn parse<'a>(
        raw_lines: impl Iterator<Item = &'a str>,
    ) -> Result<Vec<ActionInvocation<'a>>, Error> {
        struct IndentedLine<'a> {
            content: &'a str,
            indentation_level: usize,
        }

        let mut indented_lines = Vec::new();
        for mut raw_line in raw_lines {
            let mut indentation_level = 0;
            let unindented_line = loop {
                raw_line = raw_line.trim_start_matches(char::is_whitespace);
                raw_line = match raw_line.strip_prefix("-") {
                    None => {
                        break IndentedLine {
                            content: raw_line,
                            indentation_level,
                        }
                    }
                    Some(raw_line) => {
                        indentation_level += 1;
                        raw_line
                    }
                }
            };
        }

        let mut previous_line_indentation = 
        for indented_line in indented_lines {

        }
        todo!()
    }
}

pub struct Filler<'a> {
    words: Vec<Word<'a>>,
}

pub enum Word<'a> {
    Raw(&'a str),
}

pub struct ActionInvocation<'a> {
    contents: Vec<Word<'a>>,
    attached_invocations: Vec<ActionInvocation<'a>>,
}

pub fn parse(program: &str) -> Result<Vec<ActionInvocation>, Error> {
    match lines::parse(program.split("\n")) {
        Ok(lines) => Ok(lines),
        Err(error) => Err(match error {
            lines::Error::UnexpectedIndentation {
                line_index,
                present_indentation_level: present_indentation,
            } => Error::UnexpectedIndentation {
                line_number: line_index + 1,
                present_indentation,
            },
        }),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
